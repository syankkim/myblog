---
title: JPA-연관관계 매핑
tags: [JPA]
categories: [JPA]
img: <img width="25" alt="inflearn2" src="https://user-images.githubusercontent.com/28856435/74893276-55244f00-53cf-11ea-8a6d-90ac0c4eb72a.png">
thumbnail: ''
permalink: ''
date: 2020-02-23 23:32:55
---

연관관계 매핑에서의 @ManyToOne, @OneToMany 사용법과
연관관계 주인을 지정해본다.
<!-- excerpt -->
<!-- toc -->

### 연관관계 매핑

> 단방향, 양방향 매핑이 있다. 항상 기본이 되는것은 단방향 매핑이고,
여기에 양방향으로 조회를 가능토록 해준다면 양방향.
여기서는 양방향에 단방향이 포함되므로 양방향을 기록하도록 하겠다.

우선 기본 설계를 구두화하자면,
MEMBER, ORDERS, ORDERITEM, ITEM 테이블이 존재한다.

각 테이블의 연관관계는 아래와 같다.

|TABLES|RELATION|table(FK)|
|-------|--------|----|
|MEMBER : ORDERS | 1 : N | ORDERS(MEMBER_ID) |
|ORDERS : ORDERITEM | 1 : N | ORDERITEM(ORDER_ID) |
|ORDERITEM : ITEM | N : 1 | ORDERITEM(ITEM_ID) |
<br/>

#### @ManyToOne
>1:N 관계에서 N 인쪽 객체에 설정해준다.
아래는 __Order.java__ 객체 일부이다.
위 연관관계를 기준으로 MEMBER 는 여러 ORDER 를 생성할 수 있다.

@ManyToOne 을 MEMBER_ID 에 설정해 주었는데,
Order 객체가 MEMBER_ID 를 FK 로 갖는다는 의미이다.
그리고 member 의 타입은 MEMBER 객체를 가져와 사용한다.

__Order.java__
```Java
@Entity
@Table(name="ORDERS")
public class Order {

    @ManyToOne
    @JoinColumn("MEMBER_ID")
    private Member member;

    ...
}
```

#### @OneToMany
위에서 @ManyToOne 을 MEMBER_ID 에 설정해 주었다면,
그 MEMBER_ID 가 있는 MEMBER 객체에
ORDER 객체로 orderList 를 생성해준다.

#### 연관관계 주인
여기서 연관관계 주인이 결정된다.
`@OneToMany(mappedBy = "")` mappedBy 속성에 연관관계 주인을 넣어준다.
여기서 연관관계 주인은 Order.java 에서 `@ManyToOne` 으로 설정해준 Member 객체의 member 변수 이다.

> __연관관계 주인은 FK 에 설정해준다.__

아래와 같이 Member 객체 내에 `orderList` 리스트 객체가 만들어진다.

__Member.java__
```Java
@Entity
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;
    
    // mappedBy -> Order.java 의 member 변수
    @OneToMany(mappedBy = "member")
    private List<Order> orderList = new ArrayList<Order>();
}
```

__OrderItem.java__ 도 마찬가지로 ORDER_ID 와 ITEM_ID 가 FK 이므로
@ManyToOne 을 설정해주고 객체타입을 각 Order, Item 객체로.

```java
@Entity
@Table(name = "ORDER_ITEM")
public class OrderItem {

    @Id
    @GeneratedValue
    @Column(name = "ORDER_ITEM_ID")
    private Long orderItemId;


    @ManyToOne
    @JoinColumn(name = "ORDER_ID")
    private Order order;

    @ManyToOne
    @JoinColumn(name = "ITEM_ID")
    private Item item;

```

Order 객체에는
@OneToMany 를 추가해준다.
Order 는 OderItem 리스트를 갖는다.

__Order.java__
```Java
@Entity
@Table(name="ORDERS")
public class Order {

    @ManyToOne
    @Column("MEMBER_ID")
    private Member member;

    @OneToMany(mappedBy="order")
    List<OrderItem> orderItemList = new ArrayList()<>;

    ...
}
```

Item 에서는 조회할 필요없으니 원래대로 기본키만 지정.

__Item.java__
```Java
@Entity
public class Item {

    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long itemId;
    ...
}
```

위의 방식대로 매핑을 마치면 터미널에서 아래와 같이
객체를 기준으로 한 테이블이 생성되는걸 확인할 수 있다.

```bash
   create table ITEM (
       ITEM_ID bigint not null,
        name varchar(255),
        price integer not null,
        stockQuantity integer not null,
        primary key (ITEM_ID)
    )
Hibernate: 
    
    create table Member (
       MEMBER_ID bigint not null,
        city varchar(255),
        name varchar(255),
        street varchar(255),
        zipcode varchar(255),
        primary key (MEMBER_ID)
    )
Hibernate: 
    
    create table ORDER_ITEM (
       ORDER_ITEM_ID bigint not null,
        count integer not null,
        orderPrice integer not null,
        ITEM_ID bigint,
        ORDER_ID bigint,
        primary key (ORDER_ITEM_ID)
    )
Hibernate: 
    
    create table ORDERS (
       id bigint not null,
        status varchar(255),
        MEMBER_ID bigint,
        primary key (id)
    )
```

