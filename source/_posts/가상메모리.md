---
title: ☁️ 가상메모리와 페이징 시스템
tags: ['paging_system','virtual_memory']
categories: [☁️ OS]
thumbnail: ''
permalink: ''
status: ''
date: 2021-05-13 17:34:43
---

가상메모리와 페이징 기법과 세그먼트 기법.
`#paging_system` `#virtual_memory` `#segment` `#MMU` `#TLB`
<!-- excerpt -->
<!-- toc -->

---

*💬 해당 강의는 fastcampus 에서 '컴공 전공자 따라잡기 온라인 완주반' 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.*

# 가상 메모리 (Virtual Memory System)
- 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 있다.
 - eg. 리눅스는 프로세스 하나당 4GB 이다.
- 즉, `가상 메모리`는 실제 메모리보다 많아보이게 하는 기술이다.
- 프로세스간 공간이 분리되어 프로세스 이슈가 전체 시스템에 영향을 주지 않는다.

## 가상 메모리의 사용
- 프로세스는 가상주소를 사용하고, 그 주소에 매핑되는 실제 주소는 데이터 read/write 시에만 가져온다. 
 - `virtual address`(가상주소) : 프로세스가 참조하는 주소
 - `physical address` (물리주소) : 실제 메모리 주소
- `MMU` (Memory Management Unit)
 - 가상주소의 메모리 접근이 필요할 때, 그 주소값을 물리주소로 반환해주는 하드웨어 장치이다.

## MMU (Memory Management Unit)
- CPU 는 가상메모리를 다루고, 해당 주소 접근시 `MMU 하드웨어 장치를 통해 물리메모리에 접근`한다.
 - 하드웨어 장치를 사용하면 주소 변환이 빠르기 때문에 별도 장치를 둔다.

# 페이징 시스템 (Paging System)
- 페이징이란 ?
 - 크기가 동일한 페이지로 가상주소 공간과 그에 상응하는 물리주소 공간을 관리한다.
    - page(page frame) : 고정된 크기의 block(4KB)
 - 페이징 번호를 기반으로 `가상주소-물리주소 매핑 정보를 저장`하고 사용한다.
- 리눅스에서는 보통 4KB 만큼 페이징.
- 프로세스 (4GB) 의 `PCB`에 `Page Table 구조체`를 가리키는 주소가 들어있다.


## 페이징 시스템 구조
- 페이징 시스템
 - 가상주소 = 가상메모리 페이지 + 변위
- 페이지 크기 4KB 라면, 가상주소의 `0~11bit` 변위를 나타내고, `12bit 이상`이 페이지 번호가 될 수 있다.

## 페이지 테이블 (page table)
- 프로세스 생성시 페이지 테이블 정보가 생성된다.
- 관련 페이지 테이블 base address 는 별도 `CR3 레지스터`에 저장한다.
- 물리주소에 있는 페이지 번호와 해당 페이지 번호의 첫 물리주소를 매핑한 표.
- 해당 페이지 테이블에서 해당 page 에 매핑된 첫 물리주소를 알아내고 변위를 더한값이 실제 물리주소이다.

## MMU (Memory Management Unit) : 물리주소를 얻는 방법
  MMU(하드웨어 장치) - 물리메모리를 확인하기 위해 Memory 에 갔다와야 한다.
- `CPU` 는 `virtual address`를 `MMU` 에 요청한다.
- `MMU` 는 `virtual address`로 해당 프로세스의 `PCB`의 페이지 테이블에 접근하여 `CR3 레지스터`로부터 `base address`를 얻는다.
- `MMU` 는 `base address`로, Memory의 물리주소에 접근한다.

## 다중단계 페이징 시스템
- 프로세스마다 페이지를 나누어서 메모리에 할당하면 많은 공간이 낭비된다. 필요한 부분만 페이지를 나눠서 할당하여 공간의 활용도를 높이고자 하는것에 착안했다.
- 모든 부분을 페이지도 나눌 필요없이 단계적으로 나누어서 필요한 부분만 `페이지 테이블`에 두고 이것을 `페이지 디렉토리`에 저장한다.
- 32bit 시스템에서 4KB를 위한 페이징 시스템
 - `하위 12bit` : 오프셋(변위)
 - `상위 20bit` : 페이징 번호 (2<sup>20</sup>=1048576 개의 페이징 번호)
- 페이지 번호를 나타내는 bit를 구분하여 단계를 나눈다.
 - 10bit : Page Directory
 - 10bit : Page Table
 - 20bit : OFFSET > Pysical Frame
- CR3 -> Page Directory(시작주소) -> Page Table(시작주소) -> Pysical Frame(물리 메모리에서 프레임주소)

## TLB (Translation Lookaside Buffer)
- 페이지 정보를 캐슁한다. (Pysical Address 전달/캐슁)

## 공유 메모리 (Shared Memory)
- 프로세스간 동일한 물리주소를 가리킬 수 있다.
- 공간절약, 메모리 할당 절약.
- P1(Parent) - [fork] -> P2(Child)


## 요구 페이징 (Demand Paging)
- 프로세스의 모든 데이터를 메모리에 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재한다.
- 더 이상 필요치 않은 페이지 프레임은 저장매체에 저장한다.(페이지 교체 알고리즘)
- 요구페이징 <-> 선행페이징(anticipatory paging): 미리 프로세스 관련 데이터를 모두 메모리에 올려놓고 실행.

## 페이지 폴트 (Page Fault)
- 어떤 페이지 정보가 실제 물리메모리에 없을때 `페이지폴트 인터럽트`가 발생한다.

# 전체 페이징 시스템 프로세스(feat. TLB, Page fault)

<br>

<img width="1009" alt="페이징_시스템" src="https://user-images.githubusercontent.com/28856435/118363663-62c78500-b5d0-11eb-902d-6ec65340e35c.PNG">


(a) __[CPU -> MMU]__ CPU는 `MMU` 에 가상주소를 요청한다.
(b) __[MMU -> TLB]__ 먼저 `TLB 칩`에 변환된 물리주소가 있는지 확인한다. 있다면 바로 그 정보로 (e)단계로, 없다면 (c) 단계로 진행한다.
(c) __[MMU -> Memory]__ `CR3 레지스터`로부터 해당 페이지의 테이블에 물리주소가 있는지(valid) 확인한다. -> invalid일 경우(d) 단계를 수행, valid일 경우 (e)단계로 진행한다.
 - (d-1) __[MMU -> OS]__ `Page Fault Interrupt` OS(운영체제) 에서 `page fault interrupt handling`이 수행되고
 - (d-2) __[OS -> 저장매체]__ `저장매체`에서 해당 프로세스의 페이지 정보를 찾아온다.
 - (d-3) __[저장매체 -> Memory]__ 해당 물리주소를 `메모리`에 올린다.
 - (d-4) __[Memory]__ 페이징 정보를 업데이트 한다.

(e) __[Memory -> MMU]__ 페이지 테이블에서 해당 물리주소를 가져온다.
(f) __[MMU -> Memory]__ 실제 물리주소 위치에 접근한다.
(g) __[Memory -> CPU]__ 해당 데이터를 전달한다.

---

# 페이지 교체 알고리즘

## 페이지 교체 정책 (Page replacement policy)
- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리메모리에 공간이 없다면.
 - 기존 페이지 중 하나를 저장매체로 내린다.
 - 새로운 페이지를 해당 물리공간에 올린다.

> 페이지 교체 알고리즘(Page Replacement Algorithm) : 어떤 페이지를 물리메모리에서 저장매체로 보낼것인가 ?

### FIFO 
- 가장 먼저 들어온 페이지를 내리자.

### OPT(OPTimal Replacement Algorithm)
- 최적 페이지 교체 알고리즘
- 앞으로 오랫동안 사용하지 않을 페이지를 내리자.
- 어떤 페이지가 오랫동안 사용하지 않을지 예측이 힘들다. - 일반 OS에서는 구현이 불가.

### LRU (Least Recently Used)
- 가장 오래전에 사용된 페이지를 교체한다.
- OPT 알고리즘이 현실적으로 불가하므로, 과거 기록을 기반으로 한다.
- `메모리 지역성` 에 따르면 근처의 메모리 영역을 많이 사용한다.

### LFU (Least Frequently Used)
- 가장 적게 사용된 페이지를 교체한다.

### NUR (Not Used Recently)
- 최근에 사용하지 않은 페이지부터 교체한다. (LRU와 비슷)
- 참조비트와 수정비르를 사용해 그 순서대로 페이지를 교체한다.

## Threshing (스레싱)
- 반복적으로 페이지 폴트가 발생하면, 과도하게 페이지 교체작업이 일어나 결국엔 아무 일도 수행하지 못하는 상황.

---

# 세그멘테이션 기법
- 가상메모리를 서로 `크기가 다른` 논리적 단위인 `segment`로 분할한다.
- 세그먼트의 가상주소도 페이징과 동일하게 (세그먼트번호 + 블록 내 변위) 로 찾는다.

## 내부단편화 & 외부단편화
- 내부단편화는 페이징 기법에서 나타나는 현상이다.
 - 페이지 블록만큼 데이터가 채워지지 않았을 경우.
 - 이식성을 중요시하는 리눅스는 페이징 기법으로 구현되어 있다.
- 외부단편화는 세그멘트 기법에서 나타나는 현상이다.
 - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우.









