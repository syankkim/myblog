---
title: 시스템콜과 API
tags: []
categories: [☁️ Linux]
thumbnail: ''
permalink: ''
status: ''
date: 2021-05-20 23:59:59
---

시스템콜과 API의 관계, 컴파일 과정에 대해서도 알아본다.
`#API` `#ABI` `#`
<!-- excerpt -->
<!-- toc -->

---

# 시스템콜
- 주요 시스템콜 read(), write(), open()

## 시스템콜은 어떻게 구현?

```c
mov eax, 1 // 시스템콜 번호
mov ebx, 0
int 0x80 // 소프트웨어 인터럽트 명령
```

# API
- 응용 프로그램과 분리된 `하위 호환 인터페이스`
 - eg. 시스템콜 래퍼, 입출력 라이브러리 등
 - fork() 와 같은 시스템콜 함수 사용을 위해 사용자가 사용할 수 있는 함수들의 모음을 말한다.
```c
process_fork(){
    fork()
}
```


# C 컴파일러
- 유닉스 C 컴파일러 `c`
- 리눅스 C 컴파일러 -GNU cc- gcc
- 우분투 리눅스에 gcc설치

```shell
sudo apt-get install gcc
gcc --version
gcc -o test.c test
```

## 컴파일 과정 (전처리, 컴파일, 어셈블리, 링크)
>위 코드에서 `gcc -o test.c test` 를 수행할 때 발생하는 컴파일 과정이다.

| 컴파일 과정 | 서술 |
|-----------|-------|
|(1) 전처리기 |`cpp` 라는 전처리기를 사용한다.
||전처리기가 #include 구문을 만나면 해당 `헤더 파일`을 찾아 그 내용을 순차적으로 삽입한다.
||#define, #ifdef 같은 `매크로` 구문을 치환하고 처리한다.|
|(2) C컴파일러|`ccl` 에 의해 `전단부`에서 소스코드를 어휘, 구문, 의미를 분석하고 중간코드를 생성한다.
||`중단부`에서 최적화를 거치고 `후단부`에서 `어셈블리 코드`를 생성한다.|
|(3) 어셈블러 | `as` 라는 어셈블러를 사용해 어셈블리 코드를 0과1의 기계어로 변환한다. 
||최종적으로 ELF 바이너리 포맷 구조를 갖는 `목적코드를 생성`한다.|
|(4) 링커|`ld`라는 링커를 사용한다.
|| 오브젝트 파일들과 프로그램에서 사용된 표준 C 라이브러리와 사용자 라이브러리를 링크한다.
||이 과정을 통해 `실행파일`이 만들어진다.|



# ABI (Application Binary Interface)
- 응용 프로그램 바이너리 인터페이스
- 함수 실행방식, 레지스터 활용, 시스템콜 실행, 라이브러리 링크 방식 등
- ABI가 호환되면 재컴파일 없이 동작한다. (ABI 표준)
 - 리눅스에서 만든 프로그램을 리눅스에서 실행하지 못하는이유? ABI가 완벽하게 달라서이다.
- 컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공

## POSIX
- 유닉스 시스템 프로그래밍 인터페이스 표준
- 리차드 스톨만이 POSIX를 표준안 이름으로 제안
- IEEE 에서 표준화 시도

## C 언어 표준
- 다양한 C 언어 변종이 존재한다.
- ANSI 에서 `ANSI C` 표준을 정립했다.
















