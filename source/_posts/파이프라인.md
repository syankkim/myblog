---
title: ⛓ 컴퓨터구조-파이프라인
tags: ['computer_science']
categories: [☁️ TIL]
thumbnail: ''
permalink: ''
status: ''
date: 2021-06-07 10:50:54
---

파이프라인은 무조건 성능이 좋을까?
세그먼트 수가 많을 수록 효과적인걸까?
`#segment` `#RISC_Processor`
<!-- excerpt -->
<!-- toc -->

---


# 병렬처리

> 컴퓨터 시스템의 계산 속도의 향상을 목적으로 동시 데이터 처리기능을 제공하는 광범위한 개념의 기술.
>- 다중 기능장치를 가진 레지스터
> - 실행 장치를 동시에 동작되는 8개의 기능장치로 나눔


## 병렬처리 구조 분류방법 by M.J Flynn

- SISD : 단일 명령어, 단일 데이터
- SIMD : 단일 명령어, 다중 데이터
- MISD : 다중 명령어, 단일 데이터
- MIMD : - 다중 명령어, 다중 데이터
  - 여러 프로그램 동시수행 능력
  - 대부분의 다중 프로세서와 다중 컴퓨터 시스템

---

# 파이프 라인

## 파이프라인 구조 성능
- 파이프 라인의 동작은 공간, 시간표에 의해 설명되는데, 이것은 시간에 대한 함수로서 __세그먼트의 사용현황__ 을 나타낸다.
- 동일한 복잡도의 `부연산`들로 이루어지는 연산동작도 구현가능하다.
- 매번 다른 집합을 동일한 태스크에 적용해, `반복적인 일에 효과적`이다.
- __그러나,__ 각 레지스터 Ri 에 분리되는 작업들의 업무강도가 비슷해야 한다. 업무강도가 가장 높은 작업에 비중을 둘 수 밖에 없어서 `유휴시간`이 생긴다.

> 파이프라인의 `이론적 최대속도 증가율`은 `세그먼트 수와 같다.`
> - 그렇다면, 세그먼트가 많을 수록 효과적일까?


## 클럭 사이클시간

<img width="630" alt="파이프라인1" src="https://user-images.githubusercontent.com/28856435/121041772-0251ef00-c7ee-11eb-90d2-5493c5ee541b.PNG">

<br>

>위와 같은 파이프라인의 클럭 사이클시간을 구하는 공식은 아래와 같다.
> k + (n-1) 
(= k개의 세그먼트 파이프라인에서 n개의 데스크를 수행)
즉 위의 식에 대입하면 4 + (6-1)= 9
`:: 9개의 클럭사이클을 수행한다.`

## 파이프라인 구현
- 하나의 프로세스를 서로 다른 기능을 가진 서브프로세스로 나누어 각 프로세스가 `동시에` 서로 다른 데이터를 취급하도록 하는 기법
- 각 세그먼트에서 수행된 연산결과는 다음 세그먼트로 연속적으로 넘어간다.
    - 마지막 세그먼트를 통과하게되면 최종 연산결과를 얻는다.
     - 하나의 프로세스를 다양한 연산으로 중복시킬 수 있는 근간은 `세그먼트`마다의 `레지스터`이다.

- 곱셈과 덧셈이 섞인 다항식 연산
__Ai X Bi + Ci (i= 1,2,3 ...7)__
- R1 ~ R5 레지스터와 조합논리회로 (Adder, Multiplier) 구성

<img width="693" alt="파이프라인2" src="https://user-images.githubusercontent.com/28856435/121041793-08e06680-c7ee-11eb-9c19-daec02459cc3.PNG">

<br>

* 수도코드
|수도코드|설명|
|-----------------|-----------------|
|R1 <- Ai, R2 <- Bi|Ai와 Bi의 입력|
|R1 <- R1 X R2, R4 <- Ci|곱셈과 Ci의 입력|
|R1 <- R3 + R4|곱셈 결과와 Ci의 덧셈|

<br>
<br>

* __세번의 clock pulse이후부터 R5의 첫번째 결과획득__ 및 파이프 __라인상에서 데이터 이동시작__

<img width="533" alt="파이프라인3" src="https://user-images.githubusercontent.com/28856435/121213896-9fc62500-c8b9-11eb-8eaa-582963e0c47c.PNG">


## 파이프라인 데이터 처리

> * 예시
>   - 각 세그먼트에서 부연산 수행 소요시간: t<sub>p</sub>= `20ns`
>   - 파이프 라인은 `k=4` 세그먼트
>   - 태스크의 수: `n=100`

__파이프라인 구조를 활용한 경우 총 소요시간__
- (k+ n-1)t<sub>p</sub> = (4+100-1) X 20 = 2060ns

__비파이프라인 시스템__
- 각 태스크 완료시간: t<sub>n</sub>= kt<sub>p</sub> = 4 X 20 = 80ns
- 전체 태스크 완료시간: nkt<sub>p</sub> = 100 X 80 = 8000ns

__:: 속도 증가율을 확인할 수 있다.__
- 8000/2060 = 3.88 ~= 4

---

# 현실적인 파이프라인

## 파이프라인 VS 병렬 다중기능 장치
- __파이프라인__
    - 실제 파이프라인 구조는 __이론적인 최대속도 구현 불가__
        - 각 세그먼트들이 `부연산을 수행하는 시간`이 다르기 때문이다.
    - `최대 전파시간`을 갖는 세그먼트의 지연시간에 맞춰야한다.
- __병렬 다중기능 장치__
    - 그래서, 병렬적인 다중기능장치를 고려 할 수 있다.
    - 순차적 처리가 아닌, 데이터를 `동시입력` 받아 태스크를 `동시에 처리`한다. (SIMD구조)

## 파이프라인 구조

### 산술 파이프라인
- 산술 연산들을 `부연산으로 나누어` 파이프라인의 `세그먼트`에서 수행
    - 불필요한 작업을 줄일 수 있다.
    - eg. 부동 소수점 연산, 과학계산 등
- 부동 소수점 덧셈/뺄셈을 위한 파이프라인

    - 초기값이 아래와 같은 X, Y 의 ADD 연산을 산술파이프라인을 사용한다면, 표와같이 나타난다.
    X = 0.2345 X 10<sub>3</sub>
    Y = 0.1200 X 10<sub>2</sub>

|segment|result|
|-------|-------|
|Segment 1| 값이 큰 지수에 맞춘다:3|
|Segment 2| __X__ = 0.2345 X 10<sub>3</sub> __Y__ = 0.0120 X 10<sub>3</sub>|
|Segment 1| Z = 0.2465<sub>3</sub>|
|Segment 1| 정규화(항상 0으로 표현): __Z__ = 0.02465<sub>4</sub>|


### 명령어 파이프라인
> 명령어 사이클의 fetch, 디코드, 실행단계를 `중첩`사켜 명령어 흐름에 `동시에` 동작

- __취약점__ 
    - 하지만 현재 파이프라인은 `모두 비워져` 있어야한다.
    - 분기명령(`Branch`) 이후의 명령어는 무시된다.
    - 세그먼트 수행시간이 서로다르다.

- __효율적인 명령어 파이프라인?__
    - 명령어 fetch장치
        - `FIFO` 에 의한 큐로 구성하여 queuing 기법으로, 메모리를 참조 하도록 하여 접근시간을 줄인다.
    - 두개 이상의 세그먼트에 의해 주소참조 충돌이 일어날 수 있다.
        - 우선권을 주는 로직 필요

---

# 파이프라인 CPU

## 파이프라인 분기예측

- 명령어 파이프라인이 비정상적인 동작을 하는 요인
    - __1) 자원충돌__ 
        - 명령어 메모리와 데이터 메모리를 `분리`하여 해결
    - __2) 데이터 의존성__: 아직 준비되지 않은 데이터를 기다림
        - _하드웨어 인터락_
            - `피연산자`가 먼저 앞선 명령어의 목적지와 일치하는지 검사
            - 피연산자가 준비되지 않았다면 충돌을 충분히 피할만큼의 `클럭사이클`을 둔다.
        - _오퍼랜드 포워딩_ : 충돌시 특별한 `통로`를 통해서 직접 세그먼트에 전달.
    - __3) 주소 의존성__: 간접모드를 사용하는 명령어는 주소를 참조할 경우 메모리로부터 바로 fetch 되지 못한다.
    - __4) 분기 곤란__: 분기 명령어같이 PC값을 바꾸려는 명령어에 의해 발생

- 분기 명령어 처리
    - 조건,무조건 분기는 파이프라인의 정상적인 프로그램 순서를 바꿔버린다.
        - 컴퓨터 성능 저하
    - _분기 목표 버퍼 (branch target buffer, BTB)_
        - fetch 세그먼트에 속해있는 associative memory(주소가 아닌 내용에 의해 검색가능한 장치)
        - 일종의 `레지스터`로, 이전에 실행된 `분기 명령어와 목표 명령어를 저장`하여 활용한다. (loop buffer)


## RISC Processor

> 실행 명령어 수는 증가, 작업 처리시간 감소 가능
명령어당 실행 클록수와 클록주기를 파이프라인 구조로 감소 가능

- __RISC Processor 구조적 특징__
    - 명령어 1사이클 실행을 위한 `온칩 캐쉬`
    - 간단한 명령코드, 주소지정 모드
    - 신속한 오퍼랜드 참조/문맥 전환을 위한 레지스터 집합

# 결론

> 파이프라인의 `이론적 최대속도 증가율`은 `세그먼트 수와 같다.`
> - 그렇다면 세그먼트가 많을 수록 효과적일까?
>__실제 상황은 그렇지 않다.__

- 모든 명령어는 `동일한 처리 과정`으로 처리되어야 한다.
- 파이프라인을 구성하는 각 단계의 `처리시간이 일정`해야한다.
- 모든 명령어는 `순차적`으로 실행되어야 한다.
- 각 명령어 사이에는 `의존성이 없어야 `한다.
- 명령어들 처리시 공유자원의 `충돌이 없어야` 한다.