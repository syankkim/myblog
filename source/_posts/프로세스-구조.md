---
title: 프로세스 구조와 컨텍스트 스위칭
tags: []
categories: [☁️ OS]
thumbnail: ''
permalink: ''
date: 2021-05-10 17:21:24
---

프로세스 구조에 대해 자세히, 컨텍스트 스위칭은 어떻게 일어날까?
`#context_switching` `#PC` `#SP` `#PCB`
<!-- excerpt -->
<!-- toc -->

---

*💬 해당 강의는 fastcampus 에서 '컴공 전공자 따라잡기 온라인 완주반' 강의를 들으며 스스로의 학습을 위해 작성한 포스팅입니다. 문제가 된다면 연락 부탁드립니다.*

<br>

# 프로세스란 ?
> 프로세스란 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.

# 프로세스와 프로그램
> 프로그램: 일반적으로 하드 디스크 등의 보조기억장치에 저장된 실행 코드
> 프로세스: 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭.
즉, 실행 중인 프로그램을 뜻한다. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행되는 것이다.

## 프로세스 구조
- STACK : 프로그램이 자동으로 사용하는 메모리 영역이다. 함수 내의 지역변수, 인자값, 반환값의 주소가 임시로 저장된다. 데이터가 쌓이거나 반환하기 위해 할당하는 스택의 위치를 `SP(Stack Pointer)` 라는 레지스터에 주소값을 저장한다. 하나의 데이터가 stack 에 쌓이면 다음 주소값이 SP 에서 갱신된다.
- HEAP : 프로그래머의 필요에 의해 동적으로 메모리를 할당하고자 할 때 사용되는 영역이다. C 에서의 `malloc()` 함수 사용, Java 에서의 참조타입 혹은 생성자를 선언할 경우, 메모리 공간이나 크기를 할당할 수 있다.
메모리 주소 값에 의해서만 참조되고 사용되는 영역이다
- DATA
 - BSS영역, Data영역을 구분하는 이유?
 초기화 된 데이터는 초기값을 저장해야 하므로 Data 영역에 저장되어 `ROM` 에 저장된다. 하지만 초기화 되지 않은 데이터 까지 `ROM` 에 저장되면 큰 size의 공간이 필요하므로 구분하여, 초기화 되지 않은 데이터는 `RAM` 에 저장한다.
 - BSS : 초기화 되지 않은, 선언만 된 글로벌/전역 변수
 - DATA : 초기화된 글로벌/전역 변수
- CODE(TEXT) : 프로그램 코드 (컴파일된 기계어, Read Only)

## 프로그램 코드 예시 (feat.Heap)

```C
int global_data1;
int global_data2=1;

int main (){
  int* data; // int 타입의 포인터

  data = (int*) malloc(sizeof(int)  * 4); // malloc 은 메모리를 할당해주는 동적함수.

 *data = 1;
 printf("%d\n", *data);

}
```
* 위 프로그램의 구조
|영역|데이터|
|---|---|
| stack |int* data|
| heap  data = (int*) malloc(sizeof(int)  * 4)|
| data||
| BSS |int global_data1;|
| DATA |int global_data2=1;|
| text(code)| 위의 컴파일 코드|


## 스택 오버플로우 && 힙 오버플로우
- stack과 heap영역은 사실 같은 공간을 공유한다. heap이 메모리의 낮은 주소부터 할당되면 stack은 높은 주소부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 `stack overflow`, `heap overflow` 라고 한다.
- 하나의 함수에서 너무 큰 지역변수를 선언하거나, 종료조건이 없는 재귀함수가 무한히 호출 될 경우, 버퍼를 초과하게 되어 `스택 오버플로우`가 발생한다. 이 때, return 값을 덮어쓰게 된다면 해킹의 위험에 노출된다.

## 컨텍스트 스위칭, PCB

* 컨텍스트 스위칭이란 ? 
 - Context Switching = 문맥교환
 - CPU 가 어떤 하나의 프로세스를 실행하고 있는 중, 인터럽트 요청 혹은 스케줄러에 의해 다른 우선순위의 프로세스로 교체되어 실행되는 것을 말한다.
 기존 프로세스의 상태, 레지스터값(Context) 을 저장하고, 다음 실행될 프로세스의 레지스터값으로 교체하면 CPU 는 해당값을 읽어 수행한다.

### PCB (Process Control/Context Block)
> 프로세스가 생성시 만들어지며, 프로세스마다 존재한다.
운영체제가 프로세스를 제어하기 위해 실행중인 상태를 캡쳐/구조화 하여 저장되는 구조체이다.
주기억장치에 정보가 유지된다.

* PCB 정보
 - Process ID
 - Register 값 : PC(Program Counter), SP(Stackk Pointer) 등
 - Scheduling Info (Process State)
 - Memory Info (메모리사이즈 limit)

### 컨텍스트 스위칭 과정
 <img width="326" alt="context_switching" src="https://user-images.githubusercontent.com/28856435/117633911-6f577200-b1b9-11eb-852e-56afe22a999f.png">

1. 실행중지할 프로세스를 해당 프로세스의 PCB 에 업데이트 후 메인메모리에 저장한다.
2. 메인 메모리에서 다음 실행할 프로세스의 PCB 정보를 CPU 레지스터에 넣고 실행한다.
 - `dispatch` : Ready 상태의 프로세스를 Running 상태로 바꾸는 것.

### 컴파일러 등장에 따른 컨텍스트 스위칭 속도
- 초기 : 어셈블리어로 작성되어 서로다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램 작성
 - 어셈블리어로는 프로그램 작성속도가 떨어짐.
- 컴파일러 등장 : CPU 아키텍처에 따라서 컴파일러 프로그램만 만들면 되게 되었다.
 - 어셈블리 언어로 작성된 코드보다 속도가 떨어질 수도 있음.
 - 리눅스의 경우, 각 CPU마다 다른 컨텍스트 스위칭 코드가 존재한다.